#-*- coding: utf-8 -*-
#######################################################
# 
# Configuracoes.py
# Python implementation of the Class Configuracoes
# Generated by Enterprise Architect
# Created on:      27-mai-2011 18:11:30
# Original author: Wander Jardim
# 
#######################################################

import os
import e32

PATH1 = "\\Python\\"
PATH2 = "\\Data\\python\\"
PATH3 = "\\Private\\ef0b4099\\"

class Configuracoes:
    pref = {}
    userpref = {}
    
    def __init__(self):
        """ Local onde armazenaremos os dados e configurações """
        caminho = self.__get_caminho('Pytrucos60.py')
        
        self.set_valor(self.pref, 'dir_base', caminho)
        # Ajuste para "full" se quiser que seja usada toda a tela
        self.set_valor(self.pref,'tela_jogo', 'large')
        # 'large'   # softchaves fica visivel
        # 'full'    # fica em tela cheia
        # Define o título
        self.set_valor(self.pref,'titulo_jogo', "PyTruco4S60")

    def set_valor(self,dict, chave, valor, tipo = None):
        """
        Essa função seta os pares de chave e valor em um dicionário se a chave ainda não existir.
        Se a chave já existir, não acontece nada, exceto se o tipo for específicado, aí
        então, ele tenta converter o valor para esse tipo.
        """
        if not dict.has_key(chave):
            dict[chave] = valor

        # aqui, definitivamente a chave existe 
        if tipo == 'bool':
            if dict[chave] == "False":
                dict[chave] = False
            elif dict[chave] == "True":
                dict[chave] = True
            # atenção: nunca implemente um caso else aqui, porque
            # isto destruiria as configurações padrão
        elif tipo == 'int':
            try: dict[chave] = int(dict[chave])
            except:
                print "Não é possível converter %s para %s" % (chave, tipo)
                sys.exit(-1)
        elif tipo == 'float':
            try: dict[chave] = float(dict[chave])
            except:
                print "Não é possível converter %s para %s" % (chave, tipo)
                sys.exit(-1)

    def __get_caminho(self, arquivo):
        drives_list = e32.drive_list()
        drives_list.reverse()
        for drive in [str(x) for x in drives_list]:
            if os.path.isfile(os.path.join(drive, PATH1, arquivo)):
                return os.path.join(drive, PATH1)
            elif os.path.isfile(os.path.join(drive, PATH2, arquivo)):
                return os.path.join(drive, PATH2)
            elif os.path.isfile(os.path.join(drive, PATH3, arquivo)):
                return os.path.join(drive, PATH3)
        return None